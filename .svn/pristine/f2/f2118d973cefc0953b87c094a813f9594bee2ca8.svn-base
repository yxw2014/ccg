# -*- coding: utf-8 -*-
import sys
import os
import random
import time
import json
from errors import err
from config import config
#<class 'model.BaseModel.BaseModel'>
from model.BaseModel import BaseModel
from model.HeroModel import HeroModel
from model.RoomModel import RoomModel
from pymongo.errors import AutoReconnect
						
class FightModel(BaseModel): 
	#status
	#冲锋，嘲讽 ，风怒， 圣盾， 潜行stealth，沉默silence，冰冻frozen，变形transformed, 隐秘secret
	STATUS_DEFAULT, STATUS_DASH,  STATUS_TAUNT, STATUS_WINDFURY, STATUS_SHIELD, STATUS_STEALTH, STATUS_SILENCE, STATUS_FROZEN, \
	STATUS_TRANSFORMED, STATUS_SECRET \
	= 0, 1, 2, 4, 8 ,16, 32, 64, 128, 256
	
	
	def __init__(self): 
		super(FightModel, self).__init__()
	

	@classmethod
	def checkGameOver(self, room):
		if isinstance(room, dict)== False:
			return False
		time= room.get('result')
		if time>0:
			return True
		
		return False

	@classmethod
	def checkWeapon(self, room, pos, durability):
		if isinstance(room, dict)== False or (pos!=1 and pos!= 2):
			return False
		#durability= durability- 1
		#durability= max(0, durability)
		if durability== None:
			return False
		if int(durability)== 0:
			if pos== 1:
				room['weapon1']= {}
				room['cardPlay1'][0]['atk']= 0
			else:
				room['weapon2']= {}
				room['cardPlay2'][0]['atk']= 0
		
		return True		
	
	@classmethod
	def checkAttackerAtkTime(self, card):
		if isinstance(card, dict)== False:
			return False
		time= card.get('aTime')
		if time== None or int(time)< 1:
			return False
		
		return True	
		
	'''	
	@classmethod
	def checkHeroSkillAtkTime(self, card):
		if isinstance(card, dict)== False:
			return False
		time= card.get('aTime')
		if time== None or int(time)< 1:
			return False
		
		return True
	'''	
	
	'''		
	@classmethod
	def checkAttackerStatusDash(self, card):
		if isinstance(room, dict)== False or uniqid== None or (pos!=1 and pos!= 2):
			return False
	'''
		 	
	'''
	判断嘲讽状态
	'''		
	@classmethod
	def checkTargetStatusTaunt(self, room,  pos, target): 	
		if isinstance(room, dict)== False or isinstance(target, int)== False or (pos!=1 and pos!= 2):
			return False
		#对手，所以是反的
		if pos== 1:
			cards= room['cardPlay2']
		elif pos== 2:
			cards= room['cardPlay1']
			
		ret= []	
		for k, c in enumerate(cards):
			if c.get('status')== self.STATUS_TAUNT and c.get('die')== 0 :
				ret.append(c.get('uniqid'))
		print '//////checkTargetStatusTaunt', ret, target, pos		
		if len(ret)>0 and ret.count(target)== 0:
			return True
				
		return False
	
	@classmethod
	def checkPlayCardsLimit(self, room,  pos): 	
		if isinstance(room, dict)== False or (pos!=1 and pos!= 2):
			return False
		
		if pos== 1:
			cards= room['cardPlay1']
		elif pos== 2:
			cards= room['cardPlay2']
			
		count=0
		for k, c in enumerate(cards):
			if c.get('type')!= HeroModel.HERO_HERO and c.get('die')== 0:
				count= count+ 1
				
		if count> int(config['GAME']['playCardsLimit']):
			return True
				
		return False
	
	@classmethod
	def checkHandCardsLimit(self, room,  pos): 	
		if isinstance(room, dict)== False or (pos!=1 and pos!= 2):
			return False
		
		if pos== 1:
			cards= room['cardHand1']
		elif pos== 2:
			cards= room['cardHand2']
			
		count=0
		for k, c in enumerate(cards):
			if c.get('type')!= HeroModel.HERO_HEROSKILL and c.get('die')== 0:
				count= count+ 1
				
		if count> int(config['GAME']['playCardsLimit']):
			return True
				
		return False
	
	@classmethod
	def checkAllCardsLeft(self, room,  pos): 	
		if isinstance(room, dict)== False or (pos!=1 and pos!= 2):
			return False
		
		if pos== 1:
			cards= room['cardAll1']
		elif pos== 2:
			cards= room['cardAll2']
			
					
		if len(cards)== 0:
			return True
				
		return False
	
	@classmethod
	def doCheckAllCardsLeft(self, room,  pos): 	
		if isinstance(room, dict)== False or (pos!=1 and pos!= 2):
			return False
		
		if pos== 1:		
			if self.checkAllCardsLeft(room,  pos)== True:		
				room['noCardTurn1']= room['noCardTurn1']+ 1 
				noCardTurn= room['noCardTurn1']
				room['crystal1']= room['crystal1']- noCardTurn
				room['crystal1']= max(0, room['crystal1'])
				return True
		elif pos== 2:
			if self.checkAllCardsLeft(room,  pos)== True:		
				room['noCardTurn2']= room['noCardTurn2']+ 1 
				noCardTurn= room['noCardTurn2']
				room['crystal2']= room['crystal2']- noCardTurn
				room['crystal2']= max(0, room['crystal2'])			
				return True
				
		return False
	
	@classmethod
	def checkCardDie(self, room, pos, card): 	
		if isinstance(room, dict)== False or (pos!=1 and pos!= 2) or isinstance(card, dict)== False:
			return False
		
 	    #死亡
		if card['hp']== 0:
			card['die']= 1 
			RoomModel.updatePlayCardsLocX(room, pos, card['locaX'], card['uniqid'], 1)  
			return True
				
		return False
			
			



