# -*- coding: utf-8 -*-
import sys
import os
import random
import time
import json
from pprint import pprint
from errors import err
#<class 'model.BaseModel.BaseModel'>
from model.BaseModel import BaseModel
from model.FightModel import FightModel
from model.EffectModel import EffectModel
from pymongo.errors import AutoReconnect
						
class SkillModel(BaseModel): 
	def __init__(self): 
		super(SkillModel, self).__init__()	
		
	@classmethod	
	def getSkillById(self, _id):
		if(_id== None):      
			return None
		
		try:
			data= self.mongodb['hs_skill'].find_one({"_id": _id})		
			return  data
		except AutoReconnect:
			self.log.error("mongodb error, AutoReconnect!")
			
	@classmethod	
	def parseEffect(self, uniqid, skill):
		if isinstance(skill, dict)== False or uniqid== None:
			return {}
		
		'''
		script= skill.get('script')
		if script== None:
			return {}
		
		effect= json.loads(script)
		'''
	
		obj= {}
		#技能id
		obj['skill_id']= skill.get('_id')
		
		obj['skill_name']= skill.get('name')
		#触发条件	
		obj['trigger_condition']= 0
		#触发时间
		#obj['trigger_time']= 0
		#触发者
		obj['object']= uniqid
		#触发目标
		obj['target']= uniqid
		#数值
		obj['value']= 0
		#数值来源
		obj['value_source']= 0
		#触发的事件
		obj['event']= None
		
		#effect.append(obj)
		
		return obj
	
	@classmethod	
	def parseEffectV2(self, room, uniqid, skill):
		if isinstance(skill, dict)== False or uniqid== None:
			return []
		
		
		script= skill.get('script')
		if script== None:
			return {}
		
		effect= json.loads(script)
		
	
		obj= {}
		#技能id
		obj['skill_id']= skill.get('_id')
		
		obj['skill_name']= skill.get('name')
		#触发条件	
		obj['trigger_condition']= effect['trigger']
		#触发时间
		#obj['trigger_time']= 0
		#触发者
		obj['object']= uniqid 
		#触发目标A
		obj['targetA']= effect['targetA']
		#触发目标B
		obj['targetB']= effect['targetB']
		#效果类型
		obj['type']= effect['effectType']
		#效果持续时间
		obj['continuous']= effect['continuous']
		
		return obj
	
	@classmethod	
	def parseSkillTarget(self, target, uniqid):
		if isinstance(target, dict)== False:
			return None
		ret= None
	
		
		return ret

	@classmethod	
	def triggerEffect(self, room, uniqid, effects, pos):
		if isinstance(room, dict)== False or uniqid== None or (pos!=1 and pos!= 2):
			return False
		if isinstance(effects, dict)== True:
			effects= [effects]
		if isinstance(effects, list)== True:			
			print '----------------triggerEffect', pos, effects				
			
			for e in effects:
				
				#立即触发，比如冲锋
				if e['skill_name']== 'Dash':
					return 	EffectModel.doEffectDash(room, pos, e)
				#立即触发，比如冲锋
				elif e['skill_name']== 'Taunt':
					return 	EffectModel.doEffectTaunt(room, pos, e)								  
				else:
					pass
				
				#return self.doEffect(self, room,  pos, e)
			return True		
		else:
			return False
		
		return True
	
	@classmethod
	def doEffect(self, room,  pos, effect):
		pass

	@classmethod	
	def triggerStackEffect(self, room,  pos, trigger_condition= 1):
		if isinstance(room, dict)== False or trigger_condition== None or (pos!=1 and pos!= 2):
			return None
		
		trigger_condition= str(trigger_condition)
		if pos== 1:
			effect_stack=  room['effect1']
		elif pos==2:
			effect_stack=  room['effect2']
		
		effects= effect_stack.get(trigger_condition)
		
		print '----------------triggerStackEffect', pos, effects	
		
		if isinstance(effects, list)== True:
			if len(effects)> 0:  							
				
				for e in effects:
					return self.doEffect(self, room,  pos, e)
			else:
				return None
		else:
			return None
		
		return None
	
	@classmethod	
	def getEffectByTriggerCondition(self, effects, condition):
		if isinstance(effects, dict)== False or isinstance(condition, int)== False:
			return []
		
		ret= []
		
		for index, val in enumerate(effects):
			trigger_condition= int(val.get('trigger_condition'))
			if(trigger_condition== condition):
				ret.append(val)
		return ret
	
	
	
	
