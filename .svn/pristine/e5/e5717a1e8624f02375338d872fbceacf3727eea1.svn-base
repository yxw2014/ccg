# -*- coding: utf-8 -*-
import sys
import os
import random
import time
import json
import copy
from pprint import pprint
from errors import err
from const import *
#<class 'model.BaseModel.BaseModel'>
from model.BaseModel import BaseModel
from model.RoomModel import RoomModel
from model.CardModel import CardModel
from model.FightModel import FightModel
from pymongo.errors import AutoReconnect
						
class EffectHelperModel(BaseModel): 
	def __init__(self): 
		super(EffectHelperModel, self).__init__()		
	
	@classmethod
	def __getEffectPointerTarget(self, cards, pointer, uniqids, object):
		if isinstance(cards, list)== False or isinstance(pointer, dict)== False or isinstance(uniqids, list)== False:
			return []
		all_uniqids= RoomModel.getRoomCardAllUniqid(cards)
		uniqids= [int(val) for val in uniqids]	
	
		pointer_type= pointer.get('pointerType')
		pointer_value= pointer.get('pointerValue')
		if pointer_type== None or pointer_value== None:
			return []
		if str(pointer_type)=='' or int(pointer_value)<= 0:
			self.log.error('doEffectAddAtk, Configuration error')
			return []
			
		if pointer_type== 'playerPickX':
			print 'here', uniqids, all_uniqids
			tmp= [val for val in uniqids if val in all_uniqids]
			if len(tmp)!= len(uniqids):
				return []	
		elif pointer_type== 'single':
			if len(uniqids)>1:
				return []
			if all_uniqids.count(uniqids[0])== 0:
				return []						
		elif pointer_type== 'all':
			tmp= [val for val in uniqids if val in all_uniqids]
			uniqids= all_uniqids
		elif pointer_type== 'randomX':
			pointer_value= int(pointer_value)
			count= min(len(all_uniqids), pointer_value)
			count= max(1, pointer_value)
			if count>= len(all_uniqids):
				uniqids= all_uniqids
			else:
				uniqids= random.sample(all_uniqids, count)
		elif pointer_type== 'others':
			uniqids  = [val for val in all_uniqids if val != object]			
		else:
			return []
		return uniqids
	
	@classmethod
	def getEffectTarget(self, room, pos, effect, uniqids= []):
		if isinstance(room, dict)== False or isinstance(effect, dict)== False or (pos!=1 and pos!= 2):
			return []
		
		range= effect['targetA'].get('range')
		pointer= effect['targetA'].get('pointer')
		attribute= effect['targetA'].get('attribute')
		object= effect['object']
		
		print pointer, range, object, uniqids
		
		if range.get('thisCard')== 1:
			return [object]
		elif isinstance(pointer, dict)== True:
			field= range.get('field')
			role= range.get('role')
			camp= range.get('camp')
			pointer_type= pointer.get('pointerType')
			pointer_value= pointer.get('pointerValue')
			
			if role== None:
				role= []
			if isinstance(role, list)== False:
				role= [role]
			
			print type(role), HERO_HERO, camp
			if pos== 1:
				if camp== 'me' and len(role)==1 and role[0]== HERO_HERO:
					return [room['cardPlay1'][0]['uniqid']]
					
				if field== 'battleField' or field== None:
					if camp== None or camp== 'all':
						cards= []
						cards.extend(room['cardPlay1'])
						cards.extend(room['cardPlay2'])
					elif camp== 'me':
						k= 'cardPlay1'
						cards= copy.deepcopy(room[k]) 
					elif camp== 'enemy':	
						k= 'cardPlay2'
						cards= copy.deepcopy(room[k]) 
				else:
					return []		
			else:
				if camp== 'me' and len(role)==1 and role[0]== HERO_HERO:
					return [room['cardPlay2'][0]['uniqid']]
				
				if field== 'battleField' or field== None:
					if camp== None or camp== 'all':
						cards= []
						cards.extend(room['cardPlay1'])
						cards.extend(room['cardPlay2'])
					elif camp== 'me':
						k= 'cardPlay2'
						cards= copy.deepcopy(room[k]) 
					elif camp== 'enemy':	
						k= 'cardPlay1'
						cards= copy.deepcopy(room[k])	
				else:
					return []
				
			print range, pointer, camp	
			
			cards= [val for val in cards if role.count(val.get('type'))> 0]
			print '__getEffectPointerTarget', cards, role
			cards= self.__doEffectTargetAttributeFilter(room, pos, effect, cards, attribute)
			
			return self.__getEffectPointerTarget(cards, pointer, uniqids, object)
			
		return []
	
	@classmethod
	def __doEffectTargetAttributeFilter(self, room, pos, effect, cards, attribute):
		if attribute== None or isinstance(cards, list)== False:
			return cards
		
		#受过伤的
		if attribute== "injured":
			cards= [val for val in cards if (val.get('maxHp')> 0 and val.get('maxHp')> val.get('hp'))]	
		else:
			pass
		return cards
		
	
		
	@classmethod
	def getEffectValue(self, room, pos, effect, uniqids= []):
		if isinstance(room, dict)== False or isinstance(effect, dict)== False or (pos!=1 and pos!= 2):
			return 0
		
		values= effect.get('value')
		if isinstance(values, dict)== True:
			tp= values.get('valueType')
			if tp== 'n':				
				value= int(values.get('value'))
				if value<= 0:
					value= 1
			elif tp== 'nForRandom':
				value= int(values.get('value'))
				if value<= 0:
					value= 1
			elif tp== 'range':
				pass
			else:
				pass
		else:
			tp= None
			value= 1
				
		return value, tp
	
	@classmethod
	def getEffectContinuous(self, room, pos, effect, uniqids= []):
		if isinstance(room, dict)== False or isinstance(effect, dict)== False or (pos!=1 and pos!= 2):
			return 0
		
		continuous= effect.get('continuous')
		if isinstance(continuous, dict)== False:
			return False
		continuousType= continuous.get('continuous')
		continuousValue= continuous.get('continuousValue')
		
		if continuousType== "cardExistence":
			value= -2
		elif continuousType== "once":
			value= -1
			return True
		elif continuousType== "xTurnsFromNext":
			value= int(continuousValue)+1
		elif continuousType== "xTurnsFromNow":
			value= int(continuousValue)
		elif continuousType== "thisMatchEnd":
			value= -3
		elif continuousType== "thisTurnEnd":
			value= 1
		else:
			value= 0		
			
		return value	
	
	
	@classmethod
	def getEffectPointer(self, pos, pointer, range):
		if isinstance(range, dict)== False or (pos!=1 and pos!= 2):
			return None, None
		if range.get('thisCard')== 1:
			if pos== 1:
				k= 'cardPlay1'
				k2= None
			else:				
				k= 'cardPlay2'
				k2= None
		elif isinstance(pointer, dict)== True:
				field= range.get('field')
				role= range.get('role')
				camp= range.get('camp')
				pointer_type= pointer.get('pointerType')
				pointer_value= pointer.get('pointerValue')	
					
				if pos== 1:
					if field== 'battleField' or field== None:
						if camp== None or camp== 'all':
							k= 'cardPlay1'
							k2= 'cardPlay2'
						elif camp== 'me':
							k= 'cardPlay1'
							k2= None
						elif camp== 'enemy':	
							k= 'cardPlay2'
							k2= None
					else:
						return None, None			
				else:
					if field== 'battleField' or field== None:
						if camp== None or camp== 'all':
							k= 'cardPlay1'
							k2= 'cardPlay2'
						elif camp== 'me':
							k= 'cardPlay2'
							k2= None
						elif camp== 'enemy':	
							k= 'cardPlay1'
							k2= None	
					else:
						return None, None	
				
		return k, k2
	
	
	@classmethod
	def getEffectTurnRedisKey(self, room, uniqid, turn, type= ''):
		if type== EFFECT_TYPE_STUN:
			key= REDIS_KEY_EFFECT_STUN_TURN
		elif type== EFFECT_TYPE_TAUNT:
			key= REDIS_KEY_EFFECT_TAUNT_TURN
		elif type== EFFECT_TYPE_WINDFURY:
			key= REDIS_KEY_EFFECT_WINDFURY_TURN
		else:
			return None
		return key
		
	@classmethod
	def setEffectTurn(self, room, uniqid, turn, type= ''):
		if isinstance(room, dict)== False or isinstance(uniqid, int)== False or isinstance(turn, int)== False or type== '':
			return False
		
		room_id= room['roomId']
		key= self.getEffectTurnRedisKey(room, uniqid, turn, type)
		if key== None:
			return False
		key= key  % (room_id)
		
		turn= min(20, turn)
		turn= mxn(0, turn)
		self.redis.zadd(key, uniqid, turn)	
		if self.redis.ttl(key)== None:
			self.redis.expire(key, 3600)
		return True
	
	@classmethod
	def checkEffectTurn(self, room, uniqid, type= ''):
		if isinstance(room, dict)== False or isinstance(uniqid, int)== False or type== '':
			return False
		
		room_id= room['roomId']
		key= self.getEffectTurnRedisKey(room, uniqid, turn, type)
		if key== None:
			return False
		key= key  % (room_id)

		turn= self.redis.zscore(key, uniqid)	
		if turn!=0 and turn!= None:
			return True
		else:
			return False

	@classmethod
	def updateEffectTurn(self, room, pos, uniqid, type= ''):
		if isinstance(room, dict)== False or isinstance(uniqid, int)== False or type== '' or (pos!=1 and pos!= 2):
			return False
		room_id= room['roomId']		
		key= self.getEffectTurnRedisKey(room, uniqid, turn, type)
		if key== None:
			return False
		key= key  % (room_id)
		
		turn= min(20, turn)
		turn= max(0, turn)
		
		turn= self.redis.zscore(key, uniqid)
		if turn== None:
			return False
		elif turn== 1 or turn== 0:
			self.redis.zrem(key, uniqid)
			self.removeEffectTurn(room, pos, uniqid, 0, type)
			return True
		else:
			new_turn= int(self.redis.zincrby(key, uniqid, -1))
			return True	
			 
		
	@classmethod
	def removeEffectTurn(self, room, pos, uniqid, type= ''):		
		if isinstance(room, dict)== False or isinstance(uniqid, int)== False or type== '' or (pos!=1 and pos!= 2):
			return False
		
		if pos== 1:
			k= 'cardPlay1'	 
		else:
			k= 'cardPlay2'	 
		
		if type== EFFECT_TYPE_STUN:
			status= STATUS_STUN
		elif type== EFFECT_TYPE_TAUNT:
			status= STATUS_TAUNT
		elif type== EFFECT_TYPE_WINDFURY:
			status= STATUS_WINDFURY
		else:
			return False
		
		p, v= RoomModel.getRoomCardById(room[k], uniqid)
		if p== None:
			return False
		
		room[k][p]['status']= room[k][p]['status'] ^ status
		
		return True	
	
	@classmethod
	def turnEndEffectCallBack(self, room, pos):		
		if isinstance(room, dict)== False or (pos!=1 and pos!= 2):
			return False
		
		keys= [REDIS_KEY_EFFECT_WINDFURY_TURN, REDIS_KEY_EFFECT_TAUNT_TURN, REDIS_KEY_EFFECT_STUN_TURN]
		types= [STATUS_WINDFURY, STATUS_TAUNT, STATUS_STUN]
		
		def doEffectCallBack(key, tp):
			list= self.redis.zrange(key, 0, -1, withscores=False, score_cast_func=int)
			for uniqid in list:
				uniqid= int(uniqid)
				self.updateEffectTurn(room, pos, uniqid, tp)
		
		map(doEffectCallBack, keys, types)
		
		
		
		
		
